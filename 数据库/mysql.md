## Mysql

### :one: 基础知识

### :two: 存储引擎

### :three: 索引

| 红黑树                                                       | B树                                          | B+数                                                        |
| ------------------------------------------------------------ | -------------------------------------------- | ----------------------------------------------------------- |
| B树与红黑树最大的不同在于，B树的结点可以有许多子女，从几个到几千个。 | 除根节点外的每个节点至少有t−1个关键字        | 除根节点外的内部节点，每个节点最多有m个关键字，最少有⌈m/2⌉  |
|                                                              | 每个节点存储data和key                        | 子节点存储索引                                              |
|                                                              | 叶子结点的指针为null                         | 只有叶子节点存储data,而且所有的叶子节点之间增加顺序访问指针 |
|                                                              | 一个节点内如果有x个关键字，则有x+1个孩子指针 | 一个节点内如果有x个关键字，则有x个孩子指针                  |

 ![img](https://img-blog.csdn.net/20170920132729406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1YW56aGUxMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)  

**问1：** **为什么B+树比B树更适合做系统的数据库索引和文件索引** ？

> 一般来说，索引很大，往往以索引文件的形式存储的磁盘上，索引查找时产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的时间复杂度。树高度越小，I/O次数越少。  

1）**B+树的磁盘读写代价更低**
因为B+树内部结点没有存放数据data,索引比较小，可以存放在一个Block里面，避免树形结构不断的向下查询，减少IO的开销。
2）**B+树的查询更加稳定**
<dfsdf>因为非终端结点并不是指向文件内容的结点，仅仅是作为叶子结点的关键字索引，因此所有的关键字查询都会走一条从根节点到叶子结点的路径。即s所有关键字查询的长度是一样的，查询效率稳定。B树的中序遍历过程可能需要跨层，但是B+数不需要。

3） **遍历所有的数据更方便**
B+树只要遍历叶子节点就可以实现整棵树的遍历，而其他的树形结构 要中序遍历才可以访问所有的数据。 

  **B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题**， B+树只要遍历叶子节点就可以实现整棵树的遍历。

4) **B+树支持range-query非常方便，而B树不支持** 。



**问2：B树和红黑树的区别**？

 **平衡树（AVL）**更平衡，结构上更加直观，时间效能针对读取而言更高，**但是维护起来比较麻烦！！！** 

 但是，红黑树通过它规则的设定， **每次插入和删除的平均旋转次数应该是远小于平衡树**，确保了插入和删除的最坏的时间复杂度是O(log N) 。 





### :four: 事务

#### 4.1 ACID

+ 原子性（Atomicity）
  原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
+ 一致性（Consistency）
  事务前后数据的完整性必须保持一致。如果事务执行失败，需要自动回滚到原始状态。
+ 隔离性（Isolation）
  事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
+ 持久性（Durability）
  持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响

> 事务提交后，使用redo log记录变更，undo log在失败的时候进行回滚，

#### 4.2 事务隔离级别

1. 读未提交 read-uncommited （脏读）
2. 读已提交 read-commited（ **不可重复读侧重于修改，幻读侧重于新增或删除** ）
3. 可重复读
4. 串行化

> 1、事务隔离级别为`读已提交`时，写数据只会`锁行`.
>
> 2、事务隔离级别为`可重复读时`，如果检索条件有索引的时候，默认加锁方式是`next-key` 锁；如果检索条件没有索引，更新数据时会`锁表`。 一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。
>
> 3、事务隔离级别为`串行化`时，读写数据都会`锁表`
>
> 4、隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。

### :five: 日志

### :six: 分布式数据库

#### 6.1 CAP原则

+ Consistency （一致性）
+ Availability（可用性）
+ Partition-tolerance （分区容错性）

只能同时满足其中的两项。

#### 6.2 BASE理论

+ Basically-Available (基本可用)
+ Soft-state (软状态)
+ Eventually Consitent (最终一致性)

#### 6.3 分布式事务强一致性

#####  1. 二阶段提交协议

 **[XA协议-事务管理者/资源管理者]**

1. 准备流程：事务管理者向发起准备指令，询问资源管理者预提交是否成功；

2. 提交流程：如果所有的资源管理者都回复预提交成功，则正式提交命令。

缺点：

1.**同步阻塞问题**。执行过程中，所有参与节点都是事务阻塞型的。
当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。

2.**单点故障**。由于协调者的重要性，一旦协调者发生故障。
参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）

3.**数据不一致**。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。
而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。

#####  2. 三阶段提交协议

在二阶段的基础上增加`超时机制`，并且把两阶段提交协议的第一个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。

`准备阶段` —`预提交阶段` — `提交阶段`

在2PC中，只有协调者拥有超时机制，即如果在一定时间内没有收到参与者的消息则默认失败。

在3PC中，只要超时无响应，则默认为失败。则调用者会向参与者发起中断指令，参与者接收到指令以后使用undo log 回滚。

>  在doCommit阶段[第三阶段]，如果参与者无法及时接收到来自协调者的doCommit或者abort请求时，会在等待超时之后，会继续进行事务的提交。
>
> 如果由于网络的原因，某个参与者没有接收到协调者发送的abort命令，则在超时等待以后会commit.该操作也会造成数据不一致的问题。

#### 6.4 最终一致性解决方案

##### TCC模式

- Try 阶段主要是对业务系统做检测及资源预留
- Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
- Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。

spring中使用`@compensable` 可以完成try\confirm\cancel的调用。

##### 消息队列

`正反向消息机制` + `定时任务`

> 基本思路是将本地事务和生产者的消息发送放在一个事务中，保证本地操作和消息发送要么两者都成功或者都失败。下游应用向消息系统订阅该消息，收到消息后执行相应操作。

RocketMQ首先会发送`预执行消息` 到MQ，然后进行本地事务，如果本地事务的执行结果是`commit`,则正式投递MQ消息，如果本地事务`rollback`，则删除之前发送的预执行消息。



#### 6.5 幂等性

1. 创建唯一索引，防止插入重复的数据；
2. 分库分表的情况下，唯一索引会失效，所以需要在先查询一次是数据库，然后再判断约束的资源是否存在。并发的场景下可以使用分布式锁。
3. 状态机机制。

#### 6.5 主从复制、读写分离

主从复制方式： 是使用两个或两个以上相同的数据库，将一个数据库当做**主数据库**，而另一个数据库当做**从数据库。**在**主数据库**中进行相应操作时，**从数据库**记录下所有主数据库的操作，使其二者一模一样。 有**同步复制/异步复制/半同步复制**三种方式。

读写分离： 当**主数据库**进行对数据的增删改也就是写操作时，将查询的任务交给**从数据库** 。

 ###### 6.2 集群

如果说主从复制是各司其职的话，那么集群就是一群同样的个体做着同样的事情。 

###### 4.3 哨兵模式

 里面存储的是自己本身的信息，主服务器的信息，从服务器的信息。 用一个哨兵或者是多个哨兵来监视主服务器是否在正常运行，如果有问题，则找到一个合适的从服务器来代替它。

###### 4.4 非关系型数据库

 所以面对大量的数据读写，非关系型数据库相比较于关系型数据库有着巨大的优势。 key-value存储方式，数据之间没有关联，可扩展性高。

**Redis** 数据存储在内存中，可用来做缓存。需要持久化的数据就将其存入硬盘，不需要持久化的数据，可以进行短暂的存储，提高访问速度。 

###### 4.5 事务

1. ACID特性

>

2. 事务的隔离级别
   1. 

